#!/usr/bin/python3

# maps2ometiff: converts a directory tree of tiles generated by FEI MAPS software into a single pyramid'ed OME-TIFF
# originally written by Kevin Loftis, modified to an integrated standalone routine by Damir Sudar
# copyright OHSU

import argparse
import PIL
import numpy as np
import tifffile as tf
import glob
import os
import matplotlib.pyplot as plt
import tempfile
from multiprocessing.dummy import Pool as ThreadPool
import multiprocessing
import subprocess
import xml.etree.ElementTree as ET


# Maps Image Tiler and converter to OME-TIFF
# 
# The purpose of this routine is to generate a single ome-tiff from the large EM Maps.  The MAPS program does all the stitching for us,
# however, the output is a pyramidal structure of image tiles at different resolutions.  This format is proprietary and likely efficient
# for FEI software and viewing data from a web viewer, but does not facilitate easy analysis of the data since the images are are chopped
# up into tiles spread among multiple folders.  To understand how the software stitches the tiles together, lets take a look at what the
# directory structure looks like of the output from the MAPS software.
# ```
# |data
#     |-L_0
#        |-c_1
#        |-c_2
#        ...
#     |-L_1
#        |-c_1
#        ...
#     |-L_2
#        ...
#     |-L_3
#        ...
#     |-L_4
#        |-c_1
#        |  |-tile_1.tif
#        |  |-tile_2.tif
#        |   ...
#        |-c_2
#        |  |-tile_1.tif
#        |  |-tile_2.tif
#        |  ...
#        |-c_3
#          ...
# ```
# - `data` is the root directory of the file structure.
# - `L_0`,`L_1`,...: the resolution level of the images where L_0 is the lowest resolution and `L_{N}` is the highest resolution and the
#    resolution of the original data.  To make sure that our data is not downsampled, we use the images from the highest `L_{N}`.  The number
#    of resolution directories varies depending on how large the dataset is.
# - `c_1`,`c_2`,...:  The `c_{}` directories contain the images.  The number after the `c` corresponds to the column that each of the image
#    tiles within the directory correspond to.  The images within the directory are labeled `tile_{N}.tif` where `N` is the row in which the
#    tile belongs.
# 
# Using row and column information encoded in the file structure of each image tile we can construct the image.
# Here are the general steps of the stitching process:
# 
# - Find the number of rows and the number of columns and the size of each image tile. Each image tile will have the same size, typically 1024x1024.
#     * Using this information we can calculate the size of the stitched image (num_cols * width of image) x (num_row * height of image)
#     * In newer versions of MAPS, the number of images in each `c_{}` directory may vary.  This feature is meant to save space when taking
#       non-rectangular image. The row index encoded in the name of the file will correspond to the row in which the image sits in the larger image.
#       Unfortunately tif images only allow you to save images with a uniform number of rows and columns. To overcome this, I filled in missing
#       tiles with a tile of 0.
# 
# - Make an empty numpy array of the size of the stitched image
# - Fill it with the appropriate pixel data from the image tiles
# - save the numpy array as a BigTiff and NPY format
#      

# **To start:**
# From the arguments:
# 1. Get the absolute location of the highest resolution level in the pyramidal directory 
#     * This should end be a `l_{N}/` directory
# 2. Get the file path of where you want to save the file.
#     * The this should be a file name without an extensions; multiple intermediate files and directories will actually be saved with different
#       extensions, the ultimate one with the extension `ome.tif`

# command line processing of arguments
parser = argparse.ArgumentParser(description='maps2ometiff.py: convert a directory tree of tiles generated by FEI MAPS into a single bigtiff file and convert that into a pyramidal OME-TIFF file')
parser.add_argument("InPath", help="Provide path to the file 'pyramid.xml' in the MAPS directory tree")
parser.add_argument("OutFile", help="Provide path and basename of output file(s)")
args = parser.parse_args()

inpath = args.InPath

# parse the x and y pixelsize values from the "pyramid.xml" file selected

sizex = 1.0
sizey = 1.0
root = ET.parse(inpath).getroot()
for val in root.findall("./metadata/pixelsize/x"):
    sizex = float(val.text)
for val in root.findall("./metadata/pixelsize/y"):
    sizey = float(val.text)

(head, tail) = os.path.split(inpath)
level_paths = glob.glob('{}/l_*'.format(head))

level_paths.sort()
deeppath = level_paths.pop() + '/'
print("Deepest path is: " + deeppath)

outpath = args.OutFile
outbasename = os.path.basename(outpath)

# Example path: '../EM/EM_Data/Brenden Colson/OPTR 4474/Maps/4474-T-2_Teneo_20180509/LayersData/2D-EMmapping/4nm-px-res (stitched)/0/data/l_7/'
# Example output path: '../EM/EM_Data/Brenden Colson/OPTR 4474/Maps/4474-T-2_Teneo_20180509/4474-T-2_Teneo_20180509_4nm-px-res (stitched)'

# create a temporary path for the big tiff, the n5 repo and the final name of the output ome.tiff

OUT_PATH_TIFF = '/tmp2/{}.tif'.format(outbasename)  # **Do not edit**
OUT_PATH_n5 = '/tmp2/{}.n5'.format(outbasename)  # **Do not edit**
OUT_PATH_ometiff = '{}.ome.tif'.format(outpath)  # **Do not edit**
OUT_PATH_xml = '/tmp2/{}.xml'.format(outbasename)  # **Do not edit**
OUT_PATH_log = '/tmp2/{}.log'.format(outbasename)  # **Do not edit**

COL_IMAGE_PATHS = np.array(glob.glob('{}*'.format(deeppath)))

# If the output of the next box is empty or only contains one entry double check that your path is correct. The list of files paths should
# end in something like `PATH/col_{n}` where `n` is the col directory number
# print this or somehow check it

# print("input paths are:")
# print(COL_IMAGE_PATHS)

def get_num_rows(PATHS):
    max_num_files = 0
    for dir_ in PATHS:
        num_files = len(os.listdir(dir_))
        max_num_files = num_files if num_files>max_num_files else max_num_files
    return max_num_files


# Make sure that the num columns and the num rows makes sense. If you get 0 on one of these double check that your `PATH` is correct
# check this

num_columns = len(COL_IMAGE_PATHS)
num_rows = get_num_rows(COL_IMAGE_PATHS)

# add some checks

print("Tile layout in MAPS directory: ", num_rows, " rows by ", num_columns, " columns")


# The below block with print out the image size

rand_path = np.random.choice(COL_IMAGE_PATHS,1)[0]
rand_path = np.random.choice(glob.glob('{}/*'.format(rand_path)))
sample_tile= PIL.Image.open('{}'.format(rand_path))
tile_size = sample_tile.size
# tile_size
# print("Tile size: ", tile_size)


# A sample of an image tile. Just make sure that an image displays and that it is an EM image.  If it is not EM, you probably did something wrong
# check this

# sample_tile


# Make sure that the below image outputs an 'L'
# print this value or simply check it

# sample_tile.mode # should be 'L', if not 'L' you will need to change the dtype of the big_image numpy array
# print("Tile mode: ", sample_tile.mode)

big_image_width = tile_size[0] * num_columns
big_image_height = tile_size[1] * num_rows


# The block below prints out the total size of the MAPS image
# print this

# big_image_width,big_image_height


# The below block creates an empty numpy array of the size of the MAPS Image

big_image = np.zeros((big_image_height,big_image_width),np.uint8)


# A function that creates a list that maps each tile's file location to coordinates in the stiched image.  We create a list to parallelize
# loading the tiles data into the numpy array.  May take up to 2-5min to run.

print("Retrieving tile map from MAPS directory")

def get_tile_params():
    row_index = 0
    col_index = 0
    tile_param_list = []
    for i in range(num_columns):
        col_path = '{}c_{}'.format(deeppath, i)
        for j in range(num_rows):
            row_path= os.path.join(col_path,'tile_{}.tif'.format(j))
            if os.path.exists(row_path):
                tile_param_list.append([row_path,row_index,row_index+tile_size[1],col_index,col_index+tile_size[0]])
            else:
                tile_param_list.append(['None',row_index,row_index+tile_size[1],col_index,col_index+tile_size[0]])
            row_index+=tile_size[1]
        col_index+=tile_size[0]
        row_index=0
    return tile_param_list

tile_param_list = get_tile_params()


# Double check that the output makes sense.  Should be a list of lists of length 5 where the first item in the nested lists is the files
# path and the remaining 4 items are the pixel coordinates of the top left corner of the tile in the stitched numpy array

# check this
# print("Tile param list: ", tile_param_list[0:5])


# A function to fill the image

def fill_big_image(tile_params):
    fp = tile_params[0]
    row_start,row_end = tile_params[1],tile_params[2]
    col_start,col_end = tile_params[3],tile_params[4]
    if fp is not 'None':
        try:
            big_image[row_start:row_end, col_start:col_end] = np.array(PIL.Image.open(fp))
        except OSError:
            pass


# Run the above function across the number of cpus availble.  Depending on the size of the image, this could take a while 15min - 1hr

print("Mapping MAPS tiles into big tiff - this may take a while")

pool = ThreadPool(multiprocessing.cpu_count())
pool.map(fill_big_image, tile_param_list)
pool.close()
pool.join()


# create an OME XML header

xs = big_image_width
ys = big_image_height

part1 = """<?xml version="1.0" encoding="UTF-8"?>
<!-- Warning: this comment is an OME-XML metadata block, which contains crucial dimensional parameters and other important metadata. Please edit cautiously (if at all), and back up the original data before doing so. For more information, see the OME-TIFF web site: https://docs.openmicroscopy.org/latest/ome-model/ome-tiff/. -->
<OME xmlns="http://www.openmicroscopy.org/Schemas/OME/2016-06" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" Creator="OME Bio-Formats 6.2.1" UUID="urn:uuid:f44e8e82-3f44-4733-b6a3-43ac52b810e3" xsi:schemaLocation="http://www.openmicroscopy.org/Schemas/OME/2016-06 http://www.openmicroscopy.org/Schemas/OME/2016-06/ome.xsd">
   <Instrument ID="Instrument:0">
      <Microscope Type="Other" Model="Helios" Manufacturer="FEI"/>
      <Detector ID="Detector:0" Type="CMOS" Model="Falcon" Manufacturer="FEI"/>
   </Instrument>\n"""

part1A = "   <Image ID=\"Image:0\" Name=\"" + outbasename + ".ome.tif\">\n"

part2 = """      <Description/>
      <InstrumentRef ID="Instrument:0"/>\n"""

part2A = "      <Pixels BigEndian=\"true\" DimensionOrder=\"XYCZT\" ID=\"Pixels:0\" PhysicalSizeX=\"" + str(1000000000.0*sizex) + "\" PhysicalSizeXUnit=\"nm\" "
part2B =  "PhysicalSizeY=\"" + str(1000000000.0*sizey) + "\" PhysicalSizeYUnit=\"nm\" Interleaved=\"false\" SignificantBits=\"8\" "
part2C = "SizeC=\"1\" SizeT=\"1\" SizeX=\"" + str(xs) + "\" SizeY=\"" + str(ys) + "\" SizeZ=\"1\" Type=\"uint8\">\n"
part2D = part2A + part2B + part2C

part4 = """         <TiffData/>
      </Pixels>
   </Image>
</OME>\n"""

xmlstr = part1 + part1A + part2 + part2D + part4

of = open(OUT_PATH_xml, "w")
of.write(xmlstr)
of.close()

# Save the file

tf.imsave(OUT_PATH_TIFF,big_image,bigtiff=True,tile=(1024,1024)) #save as tiled big tiff

# convert the tiled big tiff into a pyramid n5 structure

print("Converting big tiff into a n5 structure - this may take a while")

cmd = "bioformats2raw " + OUT_PATH_TIFF + " " + OUT_PATH_n5 + " > " + OUT_PATH_log
msg = subprocess.call(cmd, shell=True)

# convert the n5 structure into a pyramid ome-tiff

print("Converting the n5 structure into a pyramid ome-tiff - this may take a while")

cmd = "raw2ometiff " + OUT_PATH_n5 + " " + OUT_PATH_ometiff + " >> " + OUT_PATH_log
msg = subprocess.call(cmd, shell=True)

# inject the OME-XML metadata string into the final OME-TIFF file

cmd = "tiffcomment -set '" + OUT_PATH_xml + "' " + OUT_PATH_ometiff
msg = subprocess.call(cmd, shell=True)
 
# delete all intermediate results

cmd = "rm -rf " + OUT_PATH_TIFF + " " + OUT_PATH_n5 + " " + OUT_PATH_xml + " " + OUT_PATH_log
msg = subprocess.call(cmd, shell=True)

print("Done")

