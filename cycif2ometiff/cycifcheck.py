#!/usr/bin/python3

# cycifcheck.py: checks a directory of files generated by the Chin Lab workflow for how well it matches expected structures
# originally written as a bash script and modified to Python3 routine by Damir Sudar
# copyright OHSU

import argparse
import sys
import pandas as pd
import glob
import os
import tempfile
import subprocess
import re

# natural_sort function properly sorts file names with number sequences such as f0, f1, ... ,f9, f10, f11 and ignores upper/lower case
def natural_sort(l): 
    convert = lambda text: int(text) if text.isdigit() else text.lower() 
    alphanum_key = lambda key: [ convert(c) for c in re.split('([0-9]+)', key) ] 
    return sorted(l, key = alphanum_key)

# Cyclic IF Image Tiler and converter to OME-TIFF
# 
# 

# The arguments:
# 1. Get the absolute location of the directory with individual tiff files
#     * This should be a directory!!
# 3. Options:
#       -v produces more verbose output

# command line processing of arguments
parser = argparse.ArgumentParser(description='cycifcheck.py: check a directory of channels generated by Chin Lab workflow')
parser.add_argument("InPath", help="Provide path to the directory containing the individual files")
parser.add_argument("-v", "--verbose", help="Be more verbose", action="store_true", default=False)
parser.add_argument("-e", "--exposure", help="Path to the file with exposure times", action="store")

args = parser.parse_args()

inpath = os.path.abspath(args.InPath)

# get a list of all files in the specified directory and sort them naturally
image_paths = list(glob.glob('{}/*'.format(inpath)))
sorted_image_paths = natural_sort(image_paths)

# the regex pattern of the single channel registered tif files
cycif_pattern_tif=re.compile("^Registered-R([0-9Q]+)_([a-zA-Z0-9-]+)\.([a-zA-Z0-9-]+)\.([a-zA-Z0-9-]+)\.([a-zA-Z0-9-]+)_([a-zA-Z0-9-]+)-Scene-([0-9]+).*_c([0-9])_*")
cycif_pattern_czi=re.compile("^R([0-9Q]+)_([a-zA-Z0-9-]+)\.([a-zA-Z0-9-]+)\.([a-zA-Z0-9-]+)\.([a-zA-Z0-9-]+)_([a-zA-Z0-9-]+)_.*.czi")

if args.verbose: print("Metadata extracted from files found:")
if args.verbose: print("Round\tBM1\tBM2\tBM3\tBM4\tName\tScene\tChannel\tFilesize")

# channel counter increments while stepping through the individual tif files
round_count = 0
prev_channel = 0
prev_round = 0
czis = False
firstfile = True

# read exposure times file if provided
if args.exposure:
    exps = pd.read_csv(args.exposure, ",")
    exps.rename(columns={"Unnamed: 0": "czi_name"}, inplace = True)
    exps_avail = True
else: exps_avail = False

for fname in sorted_image_paths:
    inbasename = os.path.basename(fname)
    if os.path.splitext(inbasename)[1] == ".czi":
        czis = True
        cycif_pattern = cycif_pattern_czi
    else:
        czis = False
        cycif_pattern = cycif_pattern_tif
        
    if cycif_pattern.match(inbasename):
        # if regex match found, extract all the embedded metadata from filename
        match = cycif_pattern.search(inbasename)
        round = match.group(1)
        bm1 = match.group(2)
        bm2 = match.group(3)
        bm3 = match.group(4)
        bm4 = match.group(5)
        basename = match.group(6)
        if czis:
            channel = 0
        else:
            scene = int(match.group(7))
            channel = int(match.group(8))

        if firstfile and (round == "1"):
            firstbase = basename
            firstfile = False

        exp_time = 0.0
        if exps_avail:
            exp_pat = "^R" + round + "_.*"
            thisR = exps.loc[exps.czi_name.str.contains(exp_pat), :]
            exp_time = float(thisR[str(channel-1)])

        if str.isnumeric(round):
             r = int(round) 
        else:
             r = prev_round

        if r > (prev_round + 1):
             if args.verbose: print("Round %d missing!!" % (prev_round + 1))
             round_count += 1

        fsize = str(int(os.path.getsize(fname)/1000000))

        if args.verbose:
            if czis:
                print("%s\t%s\t%s\t%s\t%s\t%s\t%sMB" % (round, bm1, bm2, bm3, bm4, basename, fsize), end = ' ')
            else:
                print("%s\t%s\t%s\t%s\t%s\t%s\t%d\t%d\t%sMB" % (round, bm1, bm2, bm3, bm4, basename, scene, channel, fsize), end = ' ')

        if r == 0:
            if args.verbose: print("    Skipping round R0: ", inbasename)
            continue

        if (r == prev_round and channel == prev_channel):
            if args.verbose: print("    Duplicate!!: ", inbasename)
        elif (not firstfile) and (basename != firstbase):
            if args.verbose: print("    Name inconsistent: ", inbasename)
        else:
            if args.verbose: print("    Accepting: ", inbasename)
            round_count += 1

        prev_channel = channel
        prev_round = r
        example_file = fname
    else:
         if args.verbose: print("File \"%s\" does not match regular round definition - cannot interpret. " % inbasename)


if czis: chan_count = round_count * 5
else: chan_count = round_count

if args.verbose: print("Acceptable to create a single OME.TIFF file with %d channels" % (chan_count))


if args.verbose: print("Done")

